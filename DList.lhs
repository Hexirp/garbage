# Haskellでの双方向連結リスト

Haskellでのリストは存在するが、それは単方向連結リストである。では、Haskellでは双方向リストを定義するのは可能なのだろうか？Haskellでは樹形状の再帰データ構造が基本となっていて、双方向リストはこれで定義できない。データ再帰というテクニックを使えば実現できるらしいのだが、定義が複雑になってしまう。私は簡単に双方向連結リストを定義する方法を発見した。まず、ポインタを使って定義された双方向リストを見てほしい。nは終端ノードを表す。

n-a-b-c-n

ここから分かることは、終端ノードが一つのポインタを持ち、中間ノードが二つのポインタを持つことだ。よって、ノード一つ一つはこのように定義できると考えられる。

> data DList a = LeftNil (DList a)
>              | DCon (DList a) a (DList a)
>              | RightNil (DList a)

さて、双方向連結リストと言っても、リストを代表するノードは決めなければならない。単純に一番左の終端ノードとしよう。すると、データ構造は以下のように変換される。斜め線は参照の一方通行の保持関係を示す。

n
 \
  a
   \
    b
     \
      c
       \
        n

いやいや、これでは単方向リストになってしまい、後ろに参照をたどることが出来ない。さて、ここから魔法の時間だ。後ろに参照をたどるためにこのようにする…

n
 \
  a
 / \
n   b
 \ / \
  a   c
 / \ / \
n   b   n
 \ / \ /
  a   c
 / \ / \
n   b   n
 \ / \ /
  a   c
 / \ / \
n   b   n
 \ / \ /
  a   c
 / \ / \
~~~~~~~~~

この図は無限に続く。一体どうしてこうなるのか？特別なことをしてはいない…後ろへのポインタを加えただけだ。そのせいで、前に行くだけで行き止まりに到達したら終わりの単方向連結リストと違い、後ろに行ったり前に行ったりするパターンが現れるため、無限に続くことになってしまう。さらに、複数個あるaなどは、値的に同一でも、ポインタ的に同一ではない。さて、これは遅延評価を使えば意味ある操作を行うことが出来るし、これにはポインタの循環構造が現れていないため、Haskellの樹形状の再帰データ構造で定義できるはずだ…いや、まだ無理だ。循環構造こそないものの、複数のポインタが一つのノードを参照してしまっている。

これを解決するためにはもう一つ魔法が必要だ…つまり、あり得る全ての経路を木構造に表すのだ。

n-a-n-a-n-a-*
  |   |   |
  |   |   +-*
  |   |
  |   +-b-a-*
  |     | |
  |     | +-*
  |     |
  |     +-c-*
  |       |
  |       +-*
  |
  +-b-a-n-a-*
    | |   |
    | |   +-*
    | |
    | +-b-a-*
    |   | |
    |   | +-*
    |   |
    |   +-c-*
    |     |
    |     +-*
    |
    +-c-b-a-*
      | | |
      | | +-*
      | |
      | +-c-*
      |   |
      |   +-*
      |
      +-n-c-*
          |
          +-*

この木構造はDList aに対応するのが分かると思う。ただ、DList aだからと言って、すべてが双方向連結リストを表すわけではない。双方向連結リストであるためには次の条件を満たす必要がある。

1. LeftNil (LeftNil _), RightNil (RightNil _)というようなパターンが現れない。
2. DCon a _ bがあった時、aはRightNilではない。ｂはLeftNilではない。
3. 全てのノードにおいて、次の関数が真になる。

> check :: DList a -> Bool
> check s@(LeftNil (RightNil a)) = s == a
> check s@(LeftNil (DCon a _ _)) = s == a
> check s@(RightNil (LeftNil a)) = s == a
> check s@(RightNil (DCon _ _ a)) = s == a
> check s@(DCon (LeftNil a) _ (RightNil b)) = s == a && s == b
> check s@(DCon (LeftNil a) _ (DCon b _ _)) = s == a && s == b
> check s@(DCon (DCon _ _ a) _ (RightNil b)) = s == a && s == b
> check s@(DCon (DCon _ _ a) _ (DCon b _ _)) = s == a && s == b